package com.example.educa1.activitys

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.os.Environment
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.FileProvider
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import com.example.educa1.R
import com.example.educa1.adapters.GradeHorariaAdapter
import com.example.educa1.adapters.ProgressoAdapter
import com.example.educa1.adapters.ProgressoData
import com.example.educa1.databinding.ActivityGradeHorariaBinding
import com.example.educa1.models.CelulaHorario
import com.example.educa1.models.Disciplina
import com.example.educa1.models.Professor
import com.example.educa1.models.RequisitoDisciplina
import com.example.educa1.models.Sala
import com.example.educa1.models.Turma
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.io.File
import java.io.FileOutputStream
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.pdf.PdfDocument
import android.os.Build
import android.util.Log
import androidx.core.content.ContextCompat
import com.example.educa1.GeminiManager
import com.example.educa1.SugestaoGradeIA
import com.example.educa1.SugestaoAula
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


// Em GradeHorariaActivity.kt

data class ProfessorSimples(val id: Long, val nome: String, val disciplinas: List<String>, val indisponibilidades: List<String>)
data class TurmaSimples(val id: Long, val nome: String)
data class DisciplinaSimples(val id: Long, val nome: String)
data class SalaSimples(val id: Long, val nome: String)
data class RequisitoSimples(val nomeDisciplina: String, val aulasPorSemana: Int)
data class GradeExistente(val turmaId: Long, val celulas: List<CelulaHorario>)

data class DadosParaIA(
    val turmaParaGerar: TurmaSimples,
    val requisitos: List<RequisitoSimples>,
    val professores: List<ProfessorSimples>,
    val disciplinas: List<DisciplinaSimples>,
    val salas: List<SalaSimples>,
    val gradesDeOutrasTurmas: List<GradeExistente>
)
//
//data class RespostaIA(
//    val grade: List<Map<String, Any>>,
//    // MUDE ESTA LINHA para aceitar um valor nulo
//    val relatorio: String? // Adiciona '?' para tornar o campo opcional
//)

class GradeHorariaActivity : BaseActivity() {

    private lateinit var binding: ActivityGradeHorariaBinding
    private lateinit var adapter: GradeHorariaAdapter
    private val listaDeCelulas = mutableListOf<CelulaHorario>()

    // Listas para armazenar todos os dados cadastrados
    private var listaDeTurmas = listOf<Turma>()
    private var listaDeProfessores = listOf<Professor>()
    private var listaDeDisciplinas = listOf<Disciplina>()
    private var listaDeSalas = listOf<Sala>()

    private var listaDeRequisitos = listOf<RequisitoDisciplina>() // <<< ADICIONE ESTA
    private val listaDeProgresso = mutableListOf<ProgressoData>()  // <<< ADICIONE ESTA
    private lateinit var progressoAdapter: ProgressoAdapter        // <<< ADICIONE ESTA

    // A turma que est√° sendo editada no momento
    private var turmaSelecionada: Turma? = null

//    private val DIAS_NA_SEMANA = 5
//    private val AULAS_POR_DIA = 5

    companion object {
        private const val TAG = "GradeHorariaActivity" // <<< ADICIONE ESTA LINHA
        private const val DIAS_NA_SEMANA = 5
        private const val AULAS_POR_DIA = 5
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityGradeHorariaBinding.inflate(layoutInflater)
        setContentView(binding.root)

        Log.d(TAG, "üîÑ onCreate() iniciado")

        setSupportActionBar(binding.toolbarGradeHoraria)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        binding.toolbarGradeHoraria.setNavigationIcon(R.drawable.ic_arrow_back_white)

        // Recupera a turma que foi passada pela tela anterior
        recuperarTurma()

        // Se a turma for v√°lida, configura a tela inteira
        turmaSelecionada?.let {
            supportActionBar?.title = getString(R.string.horario_turma, it.nome)
            carregarTodosOsDados() // Nova fun√ß√£o que carrega tudo de uma vez
            configurarRecyclerView()
            configurarPainelProgresso()
            atualizarPainelProgresso() // Atualiza√ß√£o inicial
            binding.gradeContainer.visibility = View.VISIBLE // Mostra a grade imediatamente
            
            // RECALCULAR CONFLITOS AP√ìS CONFIGURAR O ADAPTER
            Log.d(TAG, "üîÑ Chamando recalcularConflitosNaGrade() ap√≥s configurar adapter")
            recalcularConflitosNaGrade()
        } ?: run {
            // Caso de erro, se nenhuma turma for passada
            Toast.makeText(this, "Erro: Nenhuma turma selecionada.", Toast.LENGTH_LONG).show()
            finish()
        }

        // Bot√£o de gerar grade ser√° adicionado via menu da Toolbar
        Log.d(TAG, "‚úÖ onCreate() finalizado")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "üîÑ onResume() iniciado")
        
        // Recarregar dados quando voltar do chat ou detalhes da turma
        turmaSelecionada?.let {
            Log.d(TAG, "üìù Recarregando dados da turma: ${it.nome}")
            carregarRequisitosDaTurma() // Recarregar requisitos atualizados
            carregarGradeDaTurma()
            atualizarPainelProgresso()
            adapter.notifyDataSetChanged()
            
            // RECALCULAR CONFLITOS NO ONRESUME TAMB√âM
            Log.d(TAG, "üîÑ Chamando recalcularConflitosNaGrade() no onResume")
            recalcularConflitosNaGrade()
        } ?: run {
            Log.e(TAG, "‚ùå Turma selecionada √© null no onResume")
        }
        
        Log.d(TAG, "‚úÖ onResume() finalizado")
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // Infla o nosso arquivo de menu, adicionando o √≠cone √† barra de a√ß√£o.
        menuInflater.inflate(R.menu.grade_horaria_menu, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        // Lida com cliques nos itens do menu.
        return when (item.itemId) {
            R.id.action_detalhes -> {
                abrirDetalhesTurma()
                true
            }
            R.id.action_share -> {
                gerarECompartilharPdf()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    private fun mostrarDialogoOpcoesAula(celula: CelulaHorario, position: Int) {
        // ADICIONA A NOVA OP√á√ÉO AO ARRAY
        val opcoes = arrayOf("Editar Aula", "Remover Aula", "Declarar Aus√™ncia / Substituir")
        val titulo = "${celula.disciplina?.nome}\n(${celula.professor?.nome})"

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(titulo)
            .setItems(opcoes) { _, which ->
                when (which) {
                    0 -> { // Editar Aula
                        mostrarDialogoAlocarAula(position)
                    }
                    1 -> { // Remover Aula
                        removerAula(position)
                    }
                    2 -> { // <<< A NOVA OP√á√ÉO >>>
                        iniciarFluxoDeSubstituicao(celula, position)
                    }
                }
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }

    private fun mostrarDialogoAlocarAula(position: Int) {
        // PASSO 1: SELECIONAR DISCIPLINA
        val nomesDasDisciplinas = listaDeDisciplinas.map { it.nome }.toTypedArray()
        if (nomesDasDisciplinas.isEmpty()) {
            Toast.makeText(this, "Nenhuma disciplina cadastrada.", Toast.LENGTH_SHORT).show()
            return
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Passo 1: Selecione a Disciplina")
            .setItems(nomesDasDisciplinas) { _, whichDisciplina ->
                val disciplinaSelecionada = listaDeDisciplinas[whichDisciplina]

                // PASSO 2: PREPARAR E SELECIONAR PROFESSOR
                val professoresCompativeis = listaDeProfessores
                    .filter { it.disciplinas.contains(disciplinaSelecionada.nome) }

                if (professoresCompativeis.isEmpty()) {
                    Toast.makeText(this, "Nenhum professor cadastrado para esta disciplina.", Toast.LENGTH_SHORT).show()
                    return@setItems
                }

                val professoresComStatus = professoresCompativeis.map { professor ->
                    val turmaDoConflito = verificarConflitoDeProfessor(professor, position)
                    Pair(professor, turmaDoConflito)
                }

                val adapterProfessores = object : ArrayAdapter<Pair<Professor, String?>>(
                    this,
                    R.layout.item_selecao_professor,
                    R.id.tvNomeProfessorSelecao,
                    professoresComStatus
                ) {
                    override fun getView(pos: Int, convertView: View?, parent: ViewGroup): View {
                        val view = super.getView(pos, convertView, parent)
                        val nomeProfessorTv = view.findViewById<TextView>(R.id.tvNomeProfessorSelecao)
                        val statusProfessorTv = view.findViewById<TextView>(R.id.tvStatusProfessor)
                        val (professor, turmaDoConflito) = getItem(pos)!!

                        nomeProfessorTv.text = professor.nome
                        if (turmaDoConflito != null) {
                            statusProfessorTv.visibility = View.VISIBLE
                            statusProfessorTv.text = "Ocupado (${turmaDoConflito})"
                        } else {
                            statusProfessorTv.visibility = View.GONE
                        }
                        return view
                    }
                }

                AlertDialog.Builder(this, R.style.AlertDialogTheme)
                    .setTitle("Passo 2: Selecione o Professor")
                    .setAdapter(adapterProfessores) { _, whichProfessor ->
                        val (professorSelecionado, turmaDoConflitoProfessor) = professoresComStatus[whichProfessor]

                        // PASSO 3: SELECIONAR SALA
                        fun alocarAula(sala: Sala? = null, turmaComConflitoDeSala: String? = null) {
                            val celula = listaDeCelulas[position]
                            celula.disciplina = disciplinaSelecionada
                            celula.professor = professorSelecionado
                            celula.sala = sala
                            celula.temConflito = turmaDoConflitoProfessor != null
                            celula.temConflitoDeSala = turmaComConflitoDeSala != null

                            adapter.notifyItemChanged(position)
                            salvarGradeDaTurma()
                            atualizarPainelProgresso()
                        }

                        if (listaDeSalas.isEmpty()) {
                            alocarAula()
                            return@setAdapter
                        }

                        val salasComStatus = listaDeSalas.map { sala ->
                            val turmaDoConflito = verificarConflitoDeSala(sala, position)
                            Pair(sala, turmaDoConflito)
                        }

                        val adapterSalas = object : ArrayAdapter<Pair<Sala, String?>>(
                            this, R.layout.item_selecao_professor, R.id.tvNomeProfessorSelecao, salasComStatus
                        ) {
                            override fun getView(pos: Int, convertView: View?, parent: ViewGroup): View {
                                val view = super.getView(pos, convertView, parent)
                                val nomeSalaTv = view.findViewById<TextView>(R.id.tvNomeProfessorSelecao)
                                val statusSalaTv = view.findViewById<TextView>(R.id.tvStatusProfessor)
                                val (sala, turmaDoConflito) = getItem(pos)!!

                                nomeSalaTv.text = sala.nome
                                if (turmaDoConflito != null) {
                                    statusSalaTv.visibility = View.VISIBLE
                                    statusSalaTv.text = "Ocupada (${turmaDoConflito})"
                                } else {
                                    statusSalaTv.visibility = View.GONE
                                }
                                return view
                            }
                        }

                        AlertDialog.Builder(this, R.style.AlertDialogTheme)
                            .setTitle("Passo 3: Selecione a Sala (Opcional)")
                            .setAdapter(adapterSalas) { _, whichSala ->
                                val (salaSelecionada, turmaComConflitoDeSala) = salasComStatus[whichSala]
                                alocarAula(salaSelecionada, turmaComConflitoDeSala)
                            }
                            .setNeutralButton("Sem Sala") { _, _ -> alocarAula() }
                            .setNegativeButton("Cancelar", null)
                            .show()
                    }
                    .setNegativeButton("Cancelar", null)
                    .show()
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }

    private fun configurarRecyclerView() {
        Log.d(TAG, "üîÑ configurarRecyclerView() iniciado")
        
        adapter = GradeHorariaAdapter(
            listaDeCelulas = listaDeCelulas,
            onItemClicked = { celula, position ->
            // A L√ìGICA AGORA SE DIVIDE AQUI:
            if (celula.disciplina == null) {
                // Se a c√©lula est√° vazia, abre o di√°logo para alocar uma nova aula.
                mostrarDialogoAlocarAula(position)
            } else {
                // Se a c√©lula j√° est√° preenchida, abre um di√°logo com op√ß√µes.
                mostrarDialogoOpcoesAula(celula, position)
            }
            },
            isProfessorView = false // Vis√£o da turma (mostra professor)
        )

        val layoutManager = GridLayoutManager(this, DIAS_NA_SEMANA)
        binding.rvGradeHoraria.adapter = adapter
        binding.rvGradeHoraria.layoutManager = layoutManager
        
        Log.d(TAG, "‚úÖ configurarRecyclerView() finalizado - adapter criado")
    }

    private fun carregarTodosOsDados() {
        Log.d(TAG, "üîÑ carregarTodosOsDados() iniciado")
        
        carregarProfessores()
        carregarDisciplinas()
        carregarSalas()
        carregarTurmas() // ADICIONADO: Carregar turmas para verifica√ß√£o de conflitos
        carregarRequisitosDaTurma()
        carregarGradeDaTurma()
        
        Log.d(TAG, "‚úÖ carregarTodosOsDados() finalizado")
    }

    private fun recuperarTurma() {
        turmaSelecionada = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            intent.getParcelableExtra("TURMA_SELECIONADA", Turma::class.java)
        } else {
            @Suppress("DEPRECATION")
            intent.getParcelableExtra("TURMA_SELECIONADA")
        }
    }

    private fun carregarProfessores() {
        val prefs = getSharedPreferences(GerenciarProfessoresActivity.PREFS_NAME, MODE_PRIVATE)
        val json = prefs.getString(GerenciarProfessoresActivity.KEY_PROFESSORES, null)
        if (json != null) {
            val type = object : TypeToken<List<Professor>>() {}.type
            listaDeProfessores = Gson().fromJson(json, type)
        }
    }

    private fun carregarDisciplinas() {
        val prefs = getSharedPreferences(GerenciarDisciplinasActivity.PREFS_NAME, MODE_PRIVATE)
        val json = prefs.getString(GerenciarDisciplinasActivity.KEY_DISCIPLINAS, null)
        if (json != null) {
            val type = object : TypeToken<List<Disciplina>>() {}.type
            listaDeDisciplinas = Gson().fromJson(json, type)
        }
    }

    private fun carregarSalas() {
        val prefs = getSharedPreferences(GerenciarSalasActivity.PREFS_NAME, MODE_PRIVATE)
        val json = prefs.getString(GerenciarSalasActivity.KEY_SALAS, null)
        if (json != null) {
            val type = object : TypeToken<List<Sala>>() {}.type
            listaDeSalas = Gson().fromJson(json, type)
        }
    }

    private fun carregarTurmas() {
        val prefs = getSharedPreferences(GerenciarTurmasActivity.PREFS_NAME, MODE_PRIVATE)
        val json = prefs.getString(GerenciarTurmasActivity.KEY_TURMAS, null)
        if (json != null) {
            val type = object : TypeToken<List<Turma>>() {}.type
            listaDeTurmas = Gson().fromJson(json, type)
        }
    }

    private fun carregarGradeDaTurma() {
        Log.d(TAG, "üîÑ carregarGradeDaTurma() iniciado")
        
        val prefs = getSharedPreferences("GradesHorariasPrefs", MODE_PRIVATE)
        val json = prefs.getString("grade_${turmaSelecionada?.id}", null)

        if (json != null) {
            Log.d(TAG, "üì• Grade encontrada no SharedPreferences")
            val type = object : TypeToken<List<CelulaHorario>>() {}.type
            val gradeSalva: List<CelulaHorario> = Gson().fromJson(json, type)
            listaDeCelulas.clear()
            listaDeCelulas.addAll(gradeSalva)
            
            // REMOVIDO: recalcularConflitosNaGrade() ser√° chamado depois de configurar o adapter
        } else {
            Log.d(TAG, "üìù Gerando grade vazia")
            gerarGradeVazia()
        }
        
        Log.d(TAG, "‚úÖ carregarGradeDaTurma() finalizado")
    }

    /**
     * Recalcula todos os conflitos na grade atual
     * Esta fun√ß√£o √© chamada ap√≥s carregar a grade para garantir que os conflitos sejam exibidos corretamente
     */
    private fun recalcularConflitosNaGrade() {
        Log.d(TAG, "üîÑ recalcularConflitosNaGrade() iniciado")
        Log.d(TAG, "üìä Total de c√©lulas: ${listaDeCelulas.size}")
        Log.d(TAG, "üîç Adapter √© null? ${adapter == null}")
        Log.d(TAG, "üîç Turma selecionada: ${turmaSelecionada?.nome}")
        
        try {
            var celulasComProfessor = 0
            var conflitosDetectados = 0
            
            listaDeCelulas.forEachIndexed { posicao, celula ->
                if (celula.professor != null) {
                    celulasComProfessor++
                    Log.d(TAG, "üîç Verificando conflitos na posi√ß√£o $posicao - Professor: ${celula.professor?.nome}")
                    
                    // Verificar conflito de professor
                    val turmaDoConflitoProfessor = verificarConflitoDeProfessor(celula.professor!!, posicao)
                    celula.temConflito = turmaDoConflitoProfessor != null
                    
                    if (turmaDoConflitoProfessor != null) {
                        conflitosDetectados++
                        Log.d(TAG, "‚ö†Ô∏è Conflito de professor detectado: ${celula.professor?.nome} em conflito com turma $turmaDoConflitoProfessor")
                    }
                    
                    // Verificar conflito de sala
                    if (celula.sala != null) {
                        val turmaDoConflitoSala = verificarConflitoDeSala(celula.sala!!, posicao)
                        celula.temConflitoDeSala = turmaDoConflitoSala != null
                        
                        if (turmaDoConflitoSala != null) {
                            Log.d(TAG, "‚ö†Ô∏è Conflito de sala detectado: ${celula.sala?.nome} em conflito com turma $turmaDoConflitoSala")
                        }
                    } else {
                        celula.temConflitoDeSala = false
                    }
                } else {
                    // Se n√£o h√° professor, n√£o h√° conflitos
                    celula.temConflito = false
                    celula.temConflitoDeSala = false
                }
            }
            
            Log.d(TAG, "üìä Resumo: $celulasComProfessor c√©lulas com professor, $conflitosDetectados conflitos detectados")
            Log.d(TAG, "üîÑ Tentando chamar adapter.notifyDataSetChanged()")
            
            // Notificar o adapter que todos os itens mudaram para atualizar as cores
            if (adapter != null) {
                adapter.notifyDataSetChanged()
                Log.d(TAG, "‚úÖ adapter.notifyDataSetChanged() executado com sucesso")
            } else {
                Log.e(TAG, "‚ùå ERRO: adapter √© null! N√£o foi poss√≠vel atualizar a interface")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ERRO em recalcularConflitosNaGrade(): ${e.message}")
            e.printStackTrace()
        }
        
        Log.d(TAG, "‚úÖ recalcularConflitosNaGrade() finalizado")
    }

    private fun salvarGradeDaTurma() {
        turmaSelecionada?.let {
            val prefs = getSharedPreferences("GradesHorariasPrefs", MODE_PRIVATE).edit()
            val json = Gson().toJson(listaDeCelulas)
            prefs.putString("grade_${it.id}", json)
            prefs.apply()
        }
    }

    private fun gerarGradeVazia() {
        listaDeCelulas.clear()
        for (i in 0 until (DIAS_NA_SEMANA * AULAS_POR_DIA)) {
            listaDeCelulas.add(CelulaHorario(id = i.toString()))
        }
    }

    private fun verificarConflitoDeProfessor(professorSelecionado: Professor, posicaoDaCelula: Int): String? {
        Log.d(TAG, "üîç verificarConflitoDeProfessor() - Professor: ${professorSelecionado.nome}, Posi√ß√£o: $posicaoDaCelula")
        Log.d(TAG, "üìä Total de turmas carregadas: ${listaDeTurmas.size}")

        val slotId = getSlotIdFromPosition(posicaoDaCelula)
        if (professorSelecionado.indisponibilidades.contains(slotId)) {
            Log.d(TAG, "‚ö†Ô∏è Professor indispon√≠vel no hor√°rio")
            return "Indispon√≠vel" // Mensagem para indisponibilidade pessoal
        }

        val outrasTurmas = listaDeTurmas.filter { it.id != turmaSelecionada?.id }
        Log.d(TAG, "üìä Outras turmas para verificar: ${outrasTurmas.size}")

        val prefs = getSharedPreferences("GradesHorariasPrefs", MODE_PRIVATE)
        val gson = Gson()

        for (outraTurma in outrasTurmas) {
            Log.d(TAG, "üîç Verificando turma: ${outraTurma.nome}")
            val jsonGrade = prefs.getString("grade_${outraTurma.id}", null)
            if (jsonGrade != null) {
                val type = object : TypeToken<List<CelulaHorario>>() {}.type
                val gradeConcorrente: List<CelulaHorario> = gson.fromJson(jsonGrade, type)

                if (gradeConcorrente.size > posicaoDaCelula) {
                    val celulaConcorrente = gradeConcorrente[posicaoDaCelula]
                    Log.d(TAG, "üîç C√©lula concorrente na posi√ß√£o $posicaoDaCelula: Professor=${celulaConcorrente.professor?.nome}")

                    if (celulaConcorrente.professor?.id == professorSelecionado.id) {
                        Log.d(TAG, "‚ö†Ô∏è CONFLITO DETECTADO! Professor ${professorSelecionado.nome} j√° est√° na turma ${outraTurma.nome}")
                        // MUDAN√áA AQUI: Retorna apenas o nome da turma do conflito
                        return outraTurma.nome
                    }
                } else {
                    Log.d(TAG, "‚ö†Ô∏è Grade da turma ${outraTurma.nome} tem apenas ${gradeConcorrente.size} c√©lulas, posi√ß√£o $posicaoDaCelula n√£o existe")
                }
            } else {
                Log.d(TAG, "üìù Turma ${outraTurma.nome} n√£o tem grade salva")
            }
        }

        Log.d(TAG, "‚úÖ Nenhum conflito detectado para professor ${professorSelecionado.nome}")
        return null // Sem conflitos
    }

    private fun verificarConflitoDeSala(salaSelecionada: Sala, posicaoDaCelula: Int): String? {
        val outrasTurmas = listaDeTurmas.filter { it.id != turmaSelecionada?.id }
        val prefs = getSharedPreferences("GradesHorariasPrefs", MODE_PRIVATE)
        val gson = Gson()

        for (outraTurma in outrasTurmas) {
            val jsonGrade = prefs.getString("grade_${outraTurma.id}", null)
            if (jsonGrade != null) {
                val type = object : TypeToken<List<CelulaHorario>>() {}.type
                val gradeConcorrente: List<CelulaHorario> = gson.fromJson(jsonGrade, type)

                if (gradeConcorrente.size > posicaoDaCelula) {
                    val celulaConcorrente = gradeConcorrente[posicaoDaCelula]
                    if (celulaConcorrente.sala?.id == salaSelecionada.id) {
                        return outraTurma.nome // Retorna o nome da turma que est√° usando a sala
                    }
                }
            }
        }
        return null
    }

    private fun removerAula(position: Int) {
        // Encontra a c√©lula na nossa lista de dados
        val celulaParaLimpar = listaDeCelulas[position]

        // Limpa os dados da c√©lula
        celulaParaLimpar.disciplina = null
        celulaParaLimpar.professor = null
        celulaParaLimpar.turma = null // √â importante limpar a turma tamb√©m

        // Notifica o adapter que a c√©lula na posi√ß√£o X mudou, para que ela se redesenhe vazia
        adapter.notifyItemChanged(position)

        // Salva a grade com a c√©lula agora limpa
        salvarGradeDaTurma()
        atualizarPainelProgresso()
        Toast.makeText(this, "Aula removida.", Toast.LENGTH_SHORT).show()
    }

    private fun configurarPainelProgresso() {
        progressoAdapter = ProgressoAdapter(listaDeProgresso)
        binding.rvProgresso.adapter = progressoAdapter
        // O layout manager j√° foi definido no XML, mas podemos confirmar aqui
        binding.rvProgresso.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)
    }

    private fun carregarRequisitosDaTurma() {
        val prefs = getSharedPreferences("RequisitosTurmasPrefs", MODE_PRIVATE)
        val json = prefs.getString("requisitos_${turmaSelecionada?.id}", null)
        if (json != null) {
            val type = object : TypeToken<List<RequisitoDisciplina>>() {}.type
            // Filtra apenas os requisitos que t√™m mais de 0 aulas por semana
            listaDeRequisitos = Gson().fromJson<List<RequisitoDisciplina>>(json, type)
                .filter { it.aulasPorSemana > 0 }
        }
    }

    private fun atualizarPainelProgresso() {
        listaDeProgresso.clear()

        listaDeRequisitos.forEach { requisito ->
            // Conta quantas vezes a disciplina aparece na grade atual
            val aulasAlocadas = listaDeCelulas.count { it.disciplina?.nome == requisito.nomeDisciplina }

            listaDeProgresso.add(
                ProgressoData(
                    nomeDisciplina = requisito.nomeDisciplina,
                    aulasAlocadas = aulasAlocadas,
                    aulasRequeridas = requisito.aulasPorSemana
                )
            )
        }

        // Se o adapter j√° foi inicializado, notifica as mudan√ßas
        if (::progressoAdapter.isInitialized) {
            progressoAdapter.notifyDataSetChanged()
        }
    }

    private fun gerarECompartilharPdf() {
        Log.d(TAG, "=== EXPORTANDO GRADE PARA PDF ===")
        
        try {
            // Verificar se h√° grade para exportar
            if (listaDeCelulas.isEmpty()) {
                Toast.makeText(this, "Nenhuma grade encontrada para exportar", Toast.LENGTH_SHORT).show()
                return
            }
            
            Log.d(TAG, "Grade para exportar: ${listaDeCelulas.size} c√©lulas")
            
            // Log detalhado das primeiras c√©lulas que ser√£o exportadas
            listaDeCelulas.take(10).forEachIndexed { index, celula ->
                Log.d(TAG, "Exportando c√©lula $index: ${celula.disciplina?.nome} - ${celula.professor?.nome}")
            }
            
            // Gerar PDF da grade atual
            val pdfFile = gerarPDFTabela()
            
            if (pdfFile != null) {
                compartilharPDF(pdfFile)
            } else {
                Toast.makeText(this, "Erro ao gerar PDF", Toast.LENGTH_SHORT).show()
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao exportar PDF", e)
            Toast.makeText(this, "Erro ao exportar PDF: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    private fun gerarPDFTabela(): File? {
        try {
            Log.d(TAG, "Gerando PDF da grade atual...")
            
            // Criar documento PDF
        val pdfDocument = PdfDocument()
            val pageInfo = PdfDocument.PageInfo.Builder(842, 595, 1).create() // A4 landscape
        val page = pdfDocument.startPage(pageInfo)
            val canvas = page.canvas

            // Configurar paint
            val paint = Paint().apply {
            color = Color.BLACK
                textSize = 12f
                isAntiAlias = true
        }
            
            val paintHeader = Paint().apply {
            color = Color.WHITE
                textSize = 14f
                isAntiAlias = true
            isFakeBoldText = true
        }
            
            val paintCell = Paint().apply {
                color = Color.BLACK
                textSize = 10f
                isAntiAlias = true
            }
            
            // Configura√ß√µes da tabela
            val margin = 50f
            val tableWidth = 842f - (2 * margin)
            val tableHeight = 595f - (2 * margin)
            val cellWidth = tableWidth / 6 // 5 dias + 1 coluna para hor√°rios
            val cellHeight = tableHeight / 6 // 5 aulas + 1 linha para cabe√ßalho
            
            // Desenhar fundo
            canvas.drawColor(Color.WHITE)
            
            // Desenhar cabe√ßalho
            val diasSemana = listOf(getString(R.string.horario), getString(R.string.segunda), getString(R.string.terca), getString(R.string.quarta), getString(R.string.quinta), getString(R.string.sexta))
            for (i in 0..5) {
                val x = margin + (i * cellWidth)
                val y = margin + 20f
                
                // Fundo do cabe√ßalho
                canvas.drawRect(x, margin, x + cellWidth, margin + cellHeight, Paint().apply {
                    color = Color.rgb(76, 175, 80) // Verde prim√°rio
                })
                
                // Texto do cabe√ßalho
                canvas.drawText(diasSemana[i], x + 10f, y, paintHeader)
            }
            
            // Desenhar c√©lulas da grade
            for (dia in 0..4) {
                for (aula in 0..4) {
                    val x = margin + ((dia + 1) * cellWidth)
                    val y = margin + ((aula + 1) * cellHeight)
                    
                    // Borda da c√©lula
                    canvas.drawRect(x, y, x + cellWidth, y + cellHeight, Paint().apply {
                        color = Color.LTGRAY
                        style = Paint.Style.STROKE
                        strokeWidth = 1f
                    })
                    
                    // Conte√∫do da c√©lula
                    val indice = (aula * 5) + dia
                    if (indice < listaDeCelulas.size) {
                        val celula = listaDeCelulas[indice]
                        if (celula.disciplina != null && celula.professor != null) {
                            val texto = "${celula.disciplina?.nome}\n${celula.professor?.nome}"
                            val lines = texto.split("\n")
                            
                            lines.forEachIndexed { index, line ->
                                canvas.drawText(
                                    line,
                                    x + 5f,
                                    y + 15f + (index * 12f),
                                    paintCell
                                )
                        }
                    }
                }
            }
        }

            // Desenhar hor√°rios na primeira coluna
            for (aula in 0..4) {
                val x = margin
                val y = margin + ((aula + 1) * cellHeight)
                
                // Borda da c√©lula
                canvas.drawRect(x, y, x + cellWidth, y + cellHeight, Paint().apply {
                    color = Color.LTGRAY
                    style = Paint.Style.STROKE
                    strokeWidth = 1f
                })
                
                // Texto do hor√°rio
                canvas.drawText("${aula + 1}¬™ Aula", x + 10f, y + 20f, paintCell)
            }
            
            pdfDocument.finishPage(page)
            
            // Salvar arquivo
            val fileName = "grade_turma_${turmaSelecionada?.id}_${System.currentTimeMillis()}.pdf"
            val file = File(getExternalFilesDir(null), fileName)
            pdfDocument.writeTo(FileOutputStream(file))
            pdfDocument.close()
            
            Log.d(TAG, "PDF gerado com sucesso: ${file.absolutePath}")
            return file
            
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao gerar PDF", e)
            return null
        }
    }

    private fun compartilharPDF(pdfFile: File) {
        try {
            Log.d(TAG, "=== COMPARTILHANDO PDF ===")
            Log.d(TAG, "Arquivo: ${pdfFile.absolutePath}")
            Log.d(TAG, "Arquivo existe: ${pdfFile.exists()}")
            Log.d(TAG, "Tamanho do arquivo: ${pdfFile.length()} bytes")
            
            val uri = FileProvider.getUriForFile(
            this,
                "${packageName}.fileprovider",
                pdfFile
            )
            
            Log.d(TAG, "URI gerado: $uri")
            Log.d(TAG, "Package name: $packageName")
            
            if (uri == null) {
                Log.e(TAG, "‚ùå URI √© null - FileProvider falhou")
                Toast.makeText(this, "Erro: N√£o foi poss√≠vel gerar URI para o arquivo", Toast.LENGTH_SHORT).show()
                return
            }
            
            val intent = Intent(Intent.ACTION_SEND).apply {
            type = "application/pdf"
                putExtra(Intent.EXTRA_STREAM, uri)
                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.grade_horaria_turma, turmaSelecionada?.nome ?: ""))
                putExtra(Intent.EXTRA_TEXT, getString(R.string.grade_horaria_turma_texto, turmaSelecionada?.nome ?: ""))
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
            
            Log.d(TAG, "Intent criado: $intent")
            Log.d(TAG, "Intent action: ${intent.action}")
            Log.d(TAG, "Intent type: ${intent.type}")
            Log.d(TAG, "Intent extras: ${intent.extras}")
            
            // Verificar se h√° apps dispon√≠veis
            val chooser = Intent.createChooser(intent, getString(R.string.compartilhar_grade_horaria))
            Log.d(TAG, "Chooser criado: $chooser")
            
            Log.d(TAG, "üöÄ Iniciando activity de compartilhamento...")
            startActivity(chooser)
            Log.d(TAG, "‚úÖ Activity de compartilhamento iniciada com sucesso")
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erro ao compartilhar PDF", e)
            Log.e(TAG, "Stack trace: ${e.stackTraceToString()}")
            Toast.makeText(this, "Erro ao compartilhar PDF: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    private fun getSlotIdFromPosition(position: Int): String {
        val dia = position % DIAS_NA_SEMANA
        val horario = position / DIAS_NA_SEMANA
        return "${dia}_${horario}"
    }

    private fun iniciarFluxoDeSubstituicao(celulaOriginal: CelulaHorario, position: Int) {
        // Garante que temos as informa√ß√µes necess√°rias para come√ßar.
        val professorOriginal = celulaOriginal.professor ?: return
        val disciplinaDaAula = celulaOriginal.disciplina ?: return

        // 1. Encontra todos os professores que podem lecionar esta disciplina,
        //    excluindo o professor que est√° ausente.
        val candidatosPotenciais = listaDeProfessores.filter {
            it.id != professorOriginal.id && it.disciplinas.contains(disciplinaDaAula.nome)
        }

        if (candidatosPotenciais.isEmpty()) {
            Toast.makeText(this, "Nenhum outro professor cadastrado para lecionar ${disciplinaDaAula.nome}.", Toast.LENGTH_LONG).show()
            return
        }

        // 2. Verifica a disponibilidade de cada candidato para este hor√°rio espec√≠fico.
        val substitutosDisponiveis = candidatosPotenciais.filter { candidato ->
            // Reutilizamos nossa l√≥gica de verifica√ß√£o de conflito!
            verificarConflitoDeProfessor(candidato, position) == null
        }

        if (substitutosDisponiveis.isEmpty()) {
            Toast.makeText(this, getString(R.string.nenhum_professor_qualificado_disponivel), Toast.LENGTH_LONG).show()
            return
        }

        // 3. Mostra o di√°logo de sele√ß√£o apenas com os substitutos dispon√≠veis.
        val nomesDosSubstitutos = substitutosDisponiveis.map { it.nome }.toTypedArray()

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Selecione o Substituto")
            .setItems(nomesDosSubstitutos) { _, which ->
                val professorSubstituto = substitutosDisponiveis[which]

                // 4. Atualiza a c√©lula com o novo professor.
                val celulaParaAtualizar = listaDeCelulas[position]
                celulaParaAtualizar.professor = professorSubstituto

                // Opcional: podemos adicionar uma flag para indicar que √© uma substitui√ß√£o
                // celulaParaAtualizar.eSubstituicao = true
                // (Isso exigiria adicionar a flag na data class CelulaHorario)

                adapter.notifyItemChanged(position)
                salvarGradeDaTurma()
                atualizarPainelProgresso()

                Toast.makeText(this, "${professorSubstituto.nome} alocado(a) com sucesso.", Toast.LENGTH_SHORT).show()
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }

    private fun mostrarResultadoGeracaoHibrida(
        resultado: ResultadoAplicacao, 
        sugestaoIA: SugestaoGradeIA,
        gradeTemporaria: List<CelulaHorario>
    ) {
        Log.d(TAG, "=== MOSTRANDO RESULTADO ===")
        Log.d(TAG, "Sugest√µes aplicadas: ${resultado.sugestoesAplicadas}")
        Log.d(TAG, "Sugest√µes rejeitadas: ${resultado.sugestoesRejeitadas}")
        Log.d(TAG, "Aulas restantes: ${resultado.aulasRestantes}")
        
        val mensagem = StringBuilder()
        mensagem.append("‚úÖ Sugest√µes aplicadas: ${resultado.sugestoesAplicadas.size}\n")
        if (resultado.sugestoesAplicadas.isNotEmpty()) {
            resultado.sugestoesAplicadas.take(3).forEach { 
                mensagem.append("  ‚Ä¢ $it\n") 
            }
            if (resultado.sugestoesAplicadas.size > 3) {
                mensagem.append("  ‚Ä¢ ... e mais ${resultado.sugestoesAplicadas.size - 3}\n")
            }
        }
        
        if (resultado.sugestoesRejeitadas.isNotEmpty()) {
            mensagem.append("\n‚ùå Sugest√µes rejeitadas: ${resultado.sugestoesRejeitadas.size}\n")
            resultado.sugestoesRejeitadas.take(3).forEach { 
                mensagem.append("  ‚Ä¢ $it\n") 
            }
        }
        
        if (resultado.aulasRestantes.isNotEmpty()) {
            mensagem.append("\nüîß Aulas alocadas pelo algoritmo local: ${resultado.aulasRestantes.size}\n")
        }
        
        if (resultado.observacoesIA.isNotEmpty()) {
            mensagem.append("\nüí° Observa√ß√µes da IA:\n${resultado.observacoesIA}\n")
        }
        
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Grade Gerada com IA")
            .setMessage(mensagem.toString())
            .setPositiveButton("Aplicar Grade") { _, _ ->
                Log.d(TAG, "=== APLICANDO GRADE TEMPOR√ÅRIA ===")
                Log.d(TAG, "Grade tempor√°ria tem ${gradeTemporaria.size} c√©lulas")
                Log.d(TAG, "C√©lulas com disciplina: ${gradeTemporaria.count { it.disciplina != null }}")
                
                // APLICAR A GRADE TEMPOR√ÅRIA
                listaDeCelulas.clear()
                listaDeCelulas.addAll(gradeTemporaria)
                salvarGradeDaTurma()
                adapter.notifyDataSetChanged()
                atualizarPainelProgresso()
                Toast.makeText(this, "Grade aplicada com sucesso!", Toast.LENGTH_SHORT).show()
                
                Log.d(TAG, "Grade aplicada com sucesso!")
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }



    // FUN√á√ÉO REMOVIDA - AGORA INTEGRADA COM IA
    /*
    private fun executarAlgoritmoLocalOtimizado() {
        val aulasNaoAlocadas = mutableListOf<String>()
        val LOG_TAG = "Algoritmo"

        Thread {
            Log.d(LOG_TAG, "--- INICIANDO GERA√á√ÉO DE GRADE OTIMIZADA ---")
            val gradeTemporaria = listaDeCelulas.map { it.copy() }
            gradeTemporaria.forEach { it.disciplina = null; it.professor = null; it.sala = null; it.temConflito = false; it.temConflitoDeSala = false }
            val requisitosRestantes = listaDeRequisitos.associate { it.nomeDisciplina to it.aulasPorSemana }.toMutableMap()
            Log.d(LOG_TAG, "Requisitos iniciais: $requisitosRestantes")

            // <<< A CORRE√á√ÉO PRINCIPAL EST√Å AQUI >>>
            // Criamos uma lista de todas as disciplinas a serem alocadas e a embaralhamos
            // para garantir uma distribui√ß√£o justa de prioridade.
            val disciplinasParaAlocar = requisitosRestantes.keys.toList().shuffled()

            // --- FASE 1: ALOCAR AULAS DUPLAS ---
            Log.d(LOG_TAG, "--- FASE 1: Iniciando busca por AULAS DUPLAS na ordem: $disciplinasParaAlocar ---")

            // Usa a lista embaralhada para iterar
            disciplinasParaAlocar.forEach { nomeDisciplina ->
                while ((requisitosRestantes[nomeDisciplina] ?: 0) >= 2) {
                    var duplaAlocada = false
                    Log.d(LOG_TAG, "Procurando dupla para: $nomeDisciplina")

                    for (i in 0 until gradeTemporaria.size - DIAS_NA_SEMANA) {
                        val slot1 = gradeTemporaria[i]
                        val slot2 = gradeTemporaria[i + DIAS_NA_SEMANA]

                        if (i % DIAS_NA_SEMANA == (i + DIAS_NA_SEMANA) % DIAS_NA_SEMANA) {
                            if (slot1.disciplina == null && slot2.disciplina == null) {
                                val professorDisponivel = listaDeProfessores.shuffled().find { prof ->
                                    val podeLecionar = prof.disciplinas.contains(nomeDisciplina)
                                    val livreSlot1 = verificarConflitoDeProfessor(prof, i) == null
                                    val livreSlot2 = verificarConflitoDeProfessor(prof, i + DIAS_NA_SEMANA) == null
                                    podeLecionar && livreSlot1 && livreSlot2
                                }

                                if (professorDisponivel != null) {
                                    Log.i(LOG_TAG, "SUCESSO (Dupla): Alocando $nomeDisciplina com ${professorDisponivel.nome} nos slots $i e ${i + DIAS_NA_SEMANA}")
                                    val disciplinaObj = listaDeDisciplinas.find { it.nome == nomeDisciplina }
                                    slot1.disciplina = disciplinaObj; slot1.professor = professorDisponivel; slot1.turma = turmaSelecionada
                                    slot2.disciplina = disciplinaObj; slot2.professor = professorDisponivel; slot2.turma = turmaSelecionada

                                    requisitosRestantes[nomeDisciplina] = (requisitosRestantes[nomeDisciplina] ?: 0) - 2
                                    duplaAlocada = true
                                    break
                                }
                            }
                        }
                    }
                    if (!duplaAlocada) {
                        Log.w(LOG_TAG, "AVISO (Dupla): N√£o foi encontrado lugar para a dupla de $nomeDisciplina.")
                        break
                    }
                }
            }

            // --- FASE 2: ALOCAR AULAS INDIVIDUAIS RESTANTES ---
            Log.d(LOG_TAG, "--- FASE 2: Iniciando busca por AULAS INDIVIDUAIS ---")
            Log.d(LOG_TAG, "Requisitos restantes: $requisitosRestantes")

            // Usa a mesma lista embaralhada para a Fase 2, garantindo consist√™ncia
            disciplinasParaAlocar.forEach { nomeDisciplina ->
                val quantidade = requisitosRestantes[nomeDisciplina] ?: 0
                if (quantidade > 0) {
                    repeat(quantidade) {
                        var aulaIndividualAlocada = false
                        Log.d(LOG_TAG, "Procurando aula individual para: $nomeDisciplina")
                        for (i in gradeTemporaria.indices) {
                            if (gradeTemporaria[i].disciplina == null) {
                                val professorDisponivel = listaDeProfessores.shuffled().find { prof ->
                                    prof.disciplinas.contains(nomeDisciplina) &&
                                            verificarConflitoDeProfessor(prof, i) == null
                                }

                                if (professorDisponivel != null) {
                                    Log.i(LOG_TAG, "SUCESSO (Individual): Alocando $nomeDisciplina com ${professorDisponivel.nome} no slot $i")
                                    val celula = gradeTemporaria[i]
                                    celula.disciplina = listaDeDisciplinas.find { it.nome == nomeDisciplina }
                                    celula.professor = professorDisponivel
                                    celula.turma = turmaSelecionada
                                    aulaIndividualAlocada = true
                                    break
                                }
                            }
                        }
                        if (!aulaIndividualAlocada) {
                            Log.e(LOG_TAG, "FALHA (Individual): N√£o foi poss√≠vel alocar aula individual para $nomeDisciplina.")
                            aulasNaoAlocadas.add("$nomeDisciplina: N√£o foi poss√≠vel alocar aula individual restante.")
                        }
                    }
                }
            }

            // A FASE 3 de otimiza√ß√£o pode ser comentada temporariamente para simplificar a depura√ß√£o
            // --- FASE 3: OTIMIZA√á√ÉO POR TROCAS ---
            Log.d(LOG_TAG, "--- FASE 3: (Desativada para depura√ß√£o inicial) ---")

            // --- FINALIZA√á√ÉO ---
            Log.d(LOG_TAG, "--- GERA√á√ÉO CONCLU√çDA. Atualizando UI. ---")
            runOnUiThread {
                listaDeCelulas.clear()
                listaDeCelulas.addAll(gradeTemporaria)
                salvarGradeDaTurma()
                adapter.notifyDataSetChanged()
                atualizarPainelProgresso()
                mostrarDialogoRelatorioGeracao(aulasNaoAlocadas)
            }
        }.start()
    }
    */

    // FUN√á√ïES REMOVIDAS - AGORA INTEGRADAS COM IA
    /*
    private fun calcularPontuacaoJanelas(grade: List<CelulaHorario>): Int {
        var totalJanelas = 0
        // Itera sobre cada dia da semana (coluna)
        for (dia in 0 until DIAS_NA_SEMANA) {
            listaDeProfessores.forEach { professor ->
                var primeiraAulaDoDia = -1
                var ultimaAulaDoDia = -1
                var aulasNesseDia = 0

                // Encontra a primeira e a √∫ltima aula do professor neste dia
                for (horario in 0 until AULAS_POR_DIA) {
                    val index = horario * DIAS_NA_SEMANA + dia
                    if (grade[index].professor?.id == professor.id) {
                        if (primeiraAulaDoDia == -1) primeiraAulaDoDia = horario
                        ultimaAulaDoDia = horario
                        aulasNesseDia++
                    }
                }

                // Se o professor teve aulas neste dia, calcula as janelas
                if (primeiraAulaDoDia != -1) {
                    val totalSlots = ultimaAulaDoDia - primeiraAulaDoDia + 1
                    val janelas = totalSlots - aulasNesseDia
                    totalJanelas += janelas
                }
            }
        }
        return totalJanelas
    }

    /**
     * Verifica se a troca de conte√∫do entre duas c√©lulas √© v√°lida.
     */
    private fun trocaValida(celulaA: CelulaHorario, celulaB: CelulaHorario, posA: Int, posB: Int, grade: List<CelulaHorario>): Boolean {
        // Cen√°rio 1: Trocar uma aula com um slot vazio
        if (celulaA.professor != null && celulaB.professor == null) {
            // O professor da C√©lula A pode ir para o slot B?
            return verificarConflitoDeProfessor(celulaA.professor!!, posB) == null
        }
        // Cen√°rio 2: Trocar um slot vazio com uma aula
        if (celulaA.professor == null && celulaB.professor != null) {
            // O professor da C√©lula B pode ir para o slot A?
            return verificarConflitoDeProfessor(celulaB.professor!!, posA) == null
        }
        // Cen√°rio 3: Trocar duas aulas
        if (celulaA.professor != null && celulaB.professor != null) {
            // O professor da C√©lula A pode ir para o slot B?
            val profAPodeIrParaB = verificarConflitoDeProfessor(celulaA.professor!!, posB) == null
            // O professor da C√©lula B pode ir para o slot A?
            val profBPodeIrParaA = verificarConflitoDeProfessor(celulaB.professor!!, posA) == null
            return profAPodeIrParaB && profBPodeIrParaA
        }
        // Se ambas as c√©lulas est√£o vazias, a troca √© in√∫til mas v√°lida
        return true
    }

    private fun mostrarDialogoRelatorioGeracao(aulasNaoAlocadas: List<String>) {
        val totalAulasRequeridas = listaDeRequisitos.sumOf { it.aulasPorSemana }
        val aulasAlocadas = totalAulasRequeridas - aulasNaoAlocadas.size

        val titulo = "Gera√ß√£o Conclu√≠da"
        val mensagem = StringBuilder()

        mensagem.append("Resumo:\n")
        mensagem.append("  ‚Ä¢ Aulas alocadas com sucesso: $aulasAlocadas de $totalAulasRequeridas\n")
        mensagem.append("  ‚Ä¢ Falhas: ${aulasNaoAlocadas.size}\n\n")

        if (aulasNaoAlocadas.isNotEmpty()) {
            mensagem.append("Detalhes das falhas:\n")
            aulasNaoAlocadas.forEach { falha ->
                mensagem.append("  ‚Ä¢ $falha\n")
            }
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(titulo)
            .setMessage(mensagem.toString())
            .setPositiveButton("OK") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
    }
    */

    private fun abrirDetalhesTurma() {
        turmaSelecionada?.let { turma ->
            val intent = Intent(this, DetalhesTurmaActivity::class.java)
            intent.putExtra("TURMA_EXTRA", turma)
            startActivity(intent)
        }
    }

    // ===== FUN√á√ïES DE FEEDBACK VISUAL =====
    
    private fun mostrarProgressoGeracao(mensagem: String) {
        // Mostrar Toast com progresso
        Toast.makeText(this, mensagem, Toast.LENGTH_SHORT).show()
        
        // Opcional: Mostrar ProgressDialog ou overlay
        mostrarOverlayProgresso(mensagem)
    }
    
    private fun atualizarProgressoGeracao(mensagem: String) {
        // Atualizar mensagem de progresso
        Toast.makeText(this, mensagem, Toast.LENGTH_SHORT).show()
        atualizarOverlayProgresso(mensagem)
    }
    
    private fun esconderProgressoGeracao() {
        // Esconder overlay
        esconderOverlayProgresso()
    }
    
    private fun mostrarErroGeracao(mensagem: String) {
        // Mostrar erro em um AlertDialog mais amig√°vel
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("‚ùå Erro na Gera√ß√£o")
            .setMessage(mensagem)
            .setPositiveButton("OK", null)
            .show()
    }
    
    // ===== OVERLAY DE PROGRESSO =====
    
    private var progressOverlay: View? = null
    private var progressDialog: AlertDialog? = null
    
    private fun mostrarOverlayProgresso(mensagem: String) {
        // Criar overlay de progresso
        val overlay = LayoutInflater.from(this).inflate(R.layout.overlay_progresso, null)
        val tvMensagem = overlay.findViewById<TextView>(R.id.tvMensagemProgresso)
        val progressBar = overlay.findViewById<ProgressBar>(R.id.progressBar)
        
        tvMensagem.text = mensagem
        
        progressDialog = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setView(overlay)
            .setCancelable(false)
            .create()
        
        progressDialog?.show()
        progressOverlay = overlay
    }
    
    private fun atualizarOverlayProgresso(mensagem: String) {
        progressOverlay?.findViewById<TextView>(R.id.tvMensagemProgresso)?.text = mensagem
    }
    
    private fun esconderOverlayProgresso() {
        progressDialog?.dismiss()
        progressDialog = null
        progressOverlay = null
    }

    override fun onSupportNavigateUp(): Boolean {
        onBackPressedDispatcher.onBackPressed()
        return true
    }
}